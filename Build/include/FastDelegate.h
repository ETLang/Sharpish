//						Delegate.h 
//	Efficient delegates in C++ that generate only two lines of asm code!
//  Documentation is found at http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible

#pragma once
#include <memory.h> // to allow <,> comparisons
#include <memory>
#include <unordered_map>
#include <functional>
#include "Blob.h"
#include "FunctionTemplateHelp.h"

////////////////////////////////////////////////////////////////////////////////
//						Configuration options
//
////////////////////////////////////////////////////////////////////////////////

// Uncomment the following #define for optimally-sized delegates.
// In this case, the generated asm code is almost identical to the code you'd get
// if the compiler had native support for delegates.
// It will not work on systems where sizeof(dataptr) < sizeof(codeptr). 
// Thus, it will not work for DOS compilers using the medium model.
// It will also probably fail on some DSP systems.
#define FASTDELEGATE_USESTATICFUNCTIONHACK

// Uncomment the next line to allow function declarator syntax.
// It is automatically enabled for those compilers where it is known to work.
//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

////////////////////////////////////////////////////////////////////////////////
//						Compiler identification for workarounds
//
////////////////////////////////////////////////////////////////////////////////

// Compiler identification. It's not easy to identify Visual C++ because
// many vendors fraudulently define Microsoft's identifiers.
#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)
#define FASTDLGT_ISMSVC

#if (_MSC_VER <1300) // Many workarounds are required for VC6.
#define FASTDLGT_VC6
#pragma warning(disable:4786) // disable this ridiculous warning
#endif

#endif

// Does the compiler uses Microsoft's member function pointer structure?
// If so, it needs special treatment.
// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's 
// identifier, _MSC_VER. We need to filter Metrowerks out.
#if defined(_MSC_VER) && !defined(__MWERKS__)
#define FASTDLGT_MICROSOFT_MFP

#if !defined(__VECTOR_C)
// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
#define FASTDLGT_HASINHERITANCE_KEYWORDS
#endif
#endif

// Does it allow function declarator syntax? The following compilers are known to work:
#if defined(FASTDLGT_ISMSVC) && (_MSC_VER >=1310) // VC 7.1
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.
#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.
#if defined (__MWERKS__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

#ifdef __GNUC__ // Workaround GCC bug #8271 
// At present, GCC doesn't recognize constness of MFPs in templates
#define FASTDELEGATE_GCC_BUG_8271
#endif



////////////////////////////////////////////////////////////////////////////////
//						General tricks used in this code
//
// (a) Error messages are generated by typdefing an array of negative size to
//     generate compile-time errors.
// (b) Warning messages on MSVC are generated by declaring unused variables, and
//	    enabling the "variable XXX is never used" warning.
// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
//     (char *) first to ensure that the correct number of *bytes* are added.
//
////////////////////////////////////////////////////////////////////////////////
//						Helper templates
//
////////////////////////////////////////////////////////////////////////////////


namespace CS {
	namespace Details {	// we'll hide the implementation details in a nested namespace.

						//		implicit_cast< >
						// I believe this was originally going to be in the C++ standard but 
						// was left out by accident. It's even milder than static_cast.
						// I use it instead of static_cast<> to emphasize that I'm not doing
						// anything nasty. 
						// Usage is identical to static_cast<>
		template <class OutputClass, class InputClass>
		inline OutputClass implicit_cast(InputClass input) {
			return input;
		}

		//		horrible_cast< >
		// This is truly evil. It completely subverts C++'s type system, allowing you 
		// to cast from any class to any other class. Technically, using a union 
		// to perform the cast is undefined behaviour (even in C). But we can see if
		// it is OK by checking that the union is the same size as each of its members.
		// horrible_cast<> should only be used for compiler-specific workarounds. 
		// Usage is identical to reinterpret_cast<>.

		// This union is declared outside the horrible_cast because BCC 5.5.1
		// can't inline a function with a nested class, and gives a warning.
		template <class OutputClass, class InputClass>
		union horrible_union {
			OutputClass out;
			InputClass in;
		};

		template <class OutputClass, class InputClass>
		inline OutputClass horrible_cast(const InputClass input) {
			horrible_union<OutputClass, InputClass> u;
			// Cause a compile-time error if in, out and u are not the same size.
			// If the compile fails here, it means the compiler has peculiar
			// unions which would prevent the cast from working.
			typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass) == sizeof(u)
				&& sizeof(InputClass) == sizeof(OutputClass) ? 1 : -1];
			u.in = input;
			return u.out;
		}

		////////////////////////////////////////////////////////////////////////////////
		//						Workarounds
		//
		////////////////////////////////////////////////////////////////////////////////

		// Backwards compatibility: This macro used to be necessary in the virtual inheritance
		// case for Intel and Microsoft. Now it just forward-declares the class.
#define FASTDELEGATEDECLARE(CLASSNAME)	class CLASSNAME;

		// Prevent use of the static function hack with the DOS medium model.
#ifdef __MEDIUM__
#undef FASTDELEGATE_USESTATICFUNCTIONHACK
#endif

		////////////////////////////////////////////////////////////////////////////////
		//						Fast Delegates, part 1:
		//
		//		Conversion of member function pointer to a standard form
		//
		////////////////////////////////////////////////////////////////////////////////

		// GenericClass is a fake class, ONLY used to provide a type.
		// It is vitally important that it is never defined, so that the compiler doesn't
		// think it can optimize the invocation. For example, Borland generates simpler
		// code if it knows the class only uses single inheritance.

		// Compilers using Microsoft's structure need to be treated as a special case.
#ifdef  FASTDLGT_MICROSOFT_MFP

#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
		// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP 
		// (4 bytes), even when the /vmg option is used. Declaring an empty class 
		// would give 16 byte pointers in this case....
		class __single_inheritance GenericClass;
#endif
		// ...but for Codeplay, an empty class *always* gives 4 byte pointers.
		// If compiled with the /clr option ("managed C++"), the JIT compiler thinks
		// it needs to load GenericClass before it can call any of its functions,
		// (compiles OK but crashes at runtime!), so we need to declare an 
		// empty class to make it happy.
		// Codeplay and VC4 can't cope with the unknown_inheritance case either.
		class GenericClass {};
#else
		class GenericClass;
#endif

		// The size of a single inheritance member function pointer.
		const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());

		//						SimplifyMemFunc< >::Convert()
		//
		//	A template function that converts an arbitrary member function pointer into the 
		//	simplest possible form of member function pointer, using a supplied 'this' pointer.
		//  According to the standard, this can be done legally with reinterpret_cast<>.
		//	For (non-standard) compilers which use member function pointers which vary in size 
		//  depending on the class, we need to use	knowledge of the internal structure of a 
		//  member function pointer, as used by the compiler. Template specialization is used
		//  to distinguish between the sizes. Because some compilers don't support partial 
		//	template specialisation, I use full specialisation of a wrapper struct.

		// general case -- don't know how to convert it. Force a compile failure
		template <int N>
		struct SimplifyMemFunc {
			template <class X, class XFuncType, class GenericMemFuncType>
			inline static GenericClass *Convert(X *pthis, XFuncType fp,
				GenericMemFuncType &bound_func) {
				// Unsupported member function type -- force a compile failure.
				// (it's illegal to have a array with negative size).
				typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N - 100];
				return 0;
			}
		};

		// For compilers where all member func ptrs are the same size, everything goes here.
		// For non-standard compilers, only single_inheritance classes go here.
		template <>
		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE> {
			template <class X, class XFuncType, class GenericMemFuncType>
			inline static GenericClass *Convert(X *pthis, XFuncType fp,
				GenericMemFuncType &bound_func) {
#if defined __DMC__  
				// Digital Mars doesn't allow you to cast between abitrary PMF's, 
				// even though the standard says you can. The 32-bit compiler lets you
				// static_cast through an int, but the DOS compiler doesn't.
				bound_func = horrible_cast<GenericMemFuncType>(fp);
#else 
				bound_func = reinterpret_cast<GenericMemFuncType>(fp);
#endif
				return reinterpret_cast<GenericClass *>(pthis);
			}
		};

		////////////////////////////////////////////////////////////////////////////////
		//						Fast Delegates, part 1b:
		//
		//					Workarounds for Microsoft and Intel
		//
		////////////////////////////////////////////////////////////////////////////////


		// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
		// need to be treated as a special case.
#ifdef FASTDLGT_MICROSOFT_MFP

		// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
		// at the start of each function for extra safety, but VC6 seems to ICE
		// intermittently if you do this inside a template.

		// __multiple_inheritance classes go here
		// Nasty hack for Microsoft and Intel (IA32 and Itanium)
		template<>
		struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) > {
			template <class X, class XFuncType, class GenericMemFuncType>
			inline static GenericClass *Convert(X *pthis, XFuncType fp,
				GenericMemFuncType &bound_func) {
				// We need to use a horrible_cast to do this conversion.
				// In MSVC, a multiple inheritance member pointer is internally defined as:
				union {
					XFuncType func;
					struct {
						GenericMemFuncType funcaddress; // points to the actual member function
						int delta;	     // #BYTES to be added to the 'this' pointer
					}s;
				} u;
				// Check that the horrible_cast will work
				typedef int ERROR_CantUsehorrible_cast[sizeof(fp) == sizeof(u.s) ? 1 : -1];
				u.func = fp;
				bound_func = u.s.funcaddress;
				return reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta);
			}
		};

		// virtual inheritance is a real nuisance. It's inefficient and complicated.
		// On MSVC and Intel, there isn't enough information in the pointer itself to
		// enable conversion to a closure pointer. Earlier versions of this code didn't
		// work for all cases, and generated a compile-time error instead.
		// But a very clever hack invented by John M. Dlugosz solves this problem.
		// My code is somewhat different to his: I have no asm code, and I make no 
		// assumptions about the calling convention that is used.

		// In VC++ and ICL, a virtual_inheritance member pointer 
		// is internally defined as:
		struct MicrosoftVirtualMFP {
			void (GenericClass::*codeptr)(); // points to the actual member function
			int delta;		// #bytes to be added to the 'this' pointer
			int vtable_index; // or 0 if no virtual inheritance
		};
		// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
		// m_codeptr member is *always* called, regardless of the values of the other
		// members. (This is *not* true for other compilers, eg GCC, which obtain the
		// function address from the vtable if a virtual function is being called).
		// Dlugosz's trick is to make the codeptr point to a probe function which
		// returns the 'this' pointer that was used.

		// Define a generic class that uses virtual inheritance.
		// It has a trival member function that returns the value of the 'this' pointer.
		struct GenericVirtualClass : virtual public GenericClass
		{
			typedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
			GenericVirtualClass * GetThis() { return this; }
		};

		// __virtual_inheritance classes go here
		template <>
		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2 * sizeof(int) >
		{

			template <class X, class XFuncType, class GenericMemFuncType>
			inline static GenericClass *Convert(X *pthis, XFuncType fp,
				GenericMemFuncType &bound_func) {
				union {
					XFuncType func;
					GenericClass* (X::*ProbeFunc)();
					MicrosoftVirtualMFP s;
				} u;
				u.func = fp;
				bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);
				union {
					GenericVirtualClass::ProbePtrType virtfunc;
					MicrosoftVirtualMFP s;
				} u2;
				// Check that the horrible_cast<>s will work
				typedef int ERROR_CantUsehorrible_cast[sizeof(fp) == sizeof(u.s)
					&& sizeof(fp) == sizeof(u.ProbeFunc)
					&& sizeof(u2.virtfunc) == sizeof(u2.s) ? 1 : -1];
				// Unfortunately, taking the address of a MF prevents it from being inlined, so 
				// this next line can't be completely optimised away by the compiler.
				u2.virtfunc = &GenericVirtualClass::GetThis;
				u.s.codeptr = u2.s.codeptr;
				return (pthis->*u.ProbeFunc)();
			}
		};

		// Nasty hack for Microsoft and Intel (IA32 and Itanium)
		// unknown_inheritance classes go here 
		// This is probably the ugliest bit of code I've ever written. Look at the casts!
		// There is a compiler bug in MSVC6 which prevents it from using this code.
		template <>
		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3 * sizeof(int) >
		{
			template <class X, class XFuncType, class GenericMemFuncType>
			inline static GenericClass *Convert(X *pthis, XFuncType fp,
				GenericMemFuncType &bound_func) {
				// The member function pointer is 16 bytes long. We can't use a normal cast, but
				// we can use a union to do the conversion.
				union {
					XFuncType func;
					// In VC++ and ICL, an unknown_inheritance member pointer 
					// is internally defined as:
					struct {
						GenericMemFuncType m_funcaddress; // points to the actual member function
						int delta;		// #bytes to be added to the 'this' pointer
						int vtordisp;		// #bytes to add to 'this' to find the vtable
						int vtable_index; // or 0 if no virtual inheritance
					} s;
				} u;
				// Check that the horrible_cast will work
				typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType) == sizeof(u.s) ? 1 : -1];
				u.func = fp;
				bound_func = u.s.funcaddress;
				int virtual_delta = 0;
				if (u.s.vtable_index) { // Virtual inheritance is used
										// First, get to the vtable. 
										// It is 'vtordisp' bytes from the start of the class.
					const int * vtable = *reinterpret_cast<const int *const*>(
						reinterpret_cast<const char *>(pthis) + u.s.vtordisp);

					// 'vtable_index' tells us where in the table we should be looking.
					virtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>(
						reinterpret_cast<const char *>(vtable) + u.s.vtable_index);
				}
				// The int at 'virtual_delta' gives us the amount to add to 'this'.
				// Finally we can add the three components together. Phew!
				return reinterpret_cast<GenericClass *>(
					reinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);
			};
		};

#endif // MS/Intel hacks

		////////////////////////////////////////////////////////////////////////////////
		//						Fast Delegates, part 2:
		//
		//	Define the delegate storage, and cope with static functions
		//
		////////////////////////////////////////////////////////////////////////////////

		// DelegateMemento -- an opaque structure which can hold an arbitary delegate.
		// It knows nothing about the calling convention or number of arguments used by
		// the function pointed to.
		// It supplies comparison operators so that it can be stored in STL collections.
		// It cannot be set to anything other than null, nor invoked directly: 
		//   it must be converted to a specific delegate.

		// Implementation:
		// There are two possible implementations: the Safe method and the Evil method.
		//				DelegateMemento - Safe version
		//
		// This implementation is standard-compliant, but a bit tricky.
		// A static function pointer is stored inside the class. 
		// Here are the valid values:
		// +-- Static pointer --+--pthis --+-- pMemFunc-+-- Meaning------+
		// |   0				|  0       |   0        | Empty          |
		// |   !=0              |(dontcare)|  Invoker   | Static function|
		// |   0                |  !=0     |  !=0*      | Method call    |
		// +--------------------+----------+------------+----------------+
		//  * For Metrowerks, this can be 0. (first virtual function in a 
		//       single_inheritance class).
		// When stored stored inside a specific delegate, the 'dontcare' entries are replaced
		// with a reference to the delegate itself. This complicates the = and == operators
		// for the delegate class.

		//				DelegateMemento - Evil version
		//
		// For compilers where data pointers are at least as big as code pointers, it is 
		// possible to store the function pointer in the this pointer, using another 
		// horrible_cast. In this case the DelegateMemento implementation is simple:
		// +--pthis --+-- pMemFunc-+-- Meaning---------------------+
		// |    0     |  0         | Empty                         |
		// |  !=0     |  !=0*      | Static function or method call|
		// +----------+------------+-------------------------------+
		//  * For Metrowerks, this can be 0. (first virtual function in a 
		//       single_inheritance class).
		// Note that the Sun C++ and MSVC documentation explicitly state that they 
		// support static_cast between void * and function pointers.

		class DelegateMemento {
			friend struct std::hash<DelegateMemento>;

		public:
			// the data is protected, not private, because many
			// compilers have problems with template friends.
			typedef void (Details::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
			Details::GenericClass *ThisPtr;
			GenericMemFuncType MemberFn;

		protected:

#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
			typedef void(*GenericFuncPtr)(); // arbitrary code pointer
			GenericFuncPtr m_pStaticFunction;
#endif

		public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
			DelegateMemento() : ThisPtr(0), MemberFn(0), m_pStaticFunction(0) {};
			void clear() {
				ThisPtr = 0; MemberFn = 0; m_pStaticFunction = 0;
			}
#else
			DelegateMemento() : ThisPtr(0), MemberFn(0) {};
			void clear() { ThisPtr = 0; MemberFn = 0; }
#endif
		public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
			inline bool IsEqual(const DelegateMemento &x) const {
				// We have to cope with the static function pointers as a special case
				if (MemberFn != x.MemberFn) return false;
				// the static function ptrs must either both be equal, or both be 0.
				if (m_pStaticFunction != x.m_pStaticFunction) return false;
				if (m_pStaticFunction != 0) return ThisPtr == x.ThisPtr;
				else return true;
			}
#else // Evil Method
			inline bool IsEqual(const DelegateMemento &x) const {
				return ThisPtr == x.ThisPtr && MemberFn == x.MemberFn;
			}
#endif
			// Provide a strict weak ordering for DelegateMementos.
			inline bool IsLess(const DelegateMemento &right) const {
				// deal with static function pointers first
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				if (m_pStaticFunction != 0 || right.m_pStaticFunction != 0)
					return m_pStaticFunction < right.m_pStaticFunction;
#endif
				if (ThisPtr != right.ThisPtr) return ThisPtr < right.ThisPtr;
				// There are no ordering operators for member function pointers, 
				// but we can fake one by comparing each byte. The resulting ordering is
				// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
				return memcmp(&MemberFn, &right.MemberFn, sizeof(MemberFn)) < 0;

			}
			// BUGFIX (Mar 2005):
			// We can't just compare MemberFn because on Metrowerks,
			// MemberFn can be zero even if the delegate is not empty!
			inline bool operator ! () const		// Is it bound to anything?
			{
				return ThisPtr == 0 && MemberFn == 0;
			}
			inline bool empty() const		// Is it bound to anything?
			{
				return ThisPtr == 0 && MemberFn == 0;
			}
		public:
			DelegateMemento & operator = (const DelegateMemento &right) {
				SetMementoFrom(right);
				return *this;
			}
			inline bool operator <(const DelegateMemento &right) {
				return IsLess(right);
			}
			inline bool operator >(const DelegateMemento &right) {
				return right.IsLess(*this);
			}
			DelegateMemento(const DelegateMemento &right) :
				MemberFn(right.MemberFn), ThisPtr(right.ThisPtr)
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				, m_pStaticFunction(right.m_pStaticFunction)
#endif
			{}
		protected:
			void SetMementoFrom(const DelegateMemento &right) {
				MemberFn = right.MemberFn;
				ThisPtr = right.ThisPtr;
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				m_pStaticFunction = right.m_pStaticFunction;
#endif
			}
		};


		//						ClosurePtr<>
		//
		// A private wrapper class that adds function signatures to DelegateMemento.
		// It's the class that does most of the actual work.
		// The signatures are specified by:
		// GenericMemFunc: must be a type of GenericClass member function pointer. 
		// StaticFuncPtr:  must be a type of function pointer with the same signature 
		//                 as GenericMemFunc.
		// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
		//                 where it never returns void (returns DefaultVoid instead).

		template < class GenericMemFunc, class StaticFuncPtr>
		class ClosurePtr : public DelegateMemento {
		public:
			// These functions are for setting the delegate to a member function.

			// Here's the clever bit: we convert an arbitrary member function into a 
			// standard form. XMemFunc should be a member function of class X, but I can't 
			// enforce that here. It needs to be enforced by the wrapper class.
			template < class X, class XMemFunc >
			inline void bindmemfunc(X *pthis, XMemFunc fp) {
				ThisPtr = SimplifyMemFunc< sizeof(fp) >
					::Convert(pthis, fp, MemberFn);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				m_pStaticFunction = 0;
#endif
			}
			// For const member functions, we only need a const class pointer.
			// Since we know that the member function is const, it's safe to 
			// remove the const qualifier from the 'this' pointer with a const_cast.
			// VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
			template < class X, class XMemFunc>
			inline void bindconstmemfunc(const X *pthis, XMemFunc fp) {
				ThisPtr = SimplifyMemFunc< sizeof(fp) >
					::Convert(const_cast<X*>(pthis), fp, MemberFn);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				m_pStaticFunction = 0;
#endif
			}
#ifdef FASTDELEGATE_GCC_BUG_8271	// At present, GCC doesn't recognize constness of MFPs in templates
			template < class X, class XMemFunc>
			inline void bindmemfunc(const X *pthis, XMemFunc fp) {
				bindconstmemfunc(pthis, fp);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
				m_pStaticFunction = 0;
#endif
			}
#endif

			// There are a few ways of dealing with static function pointers.
			// There's a standard-compliant, but tricky method.
			// There's also a straightforward hack, that won't work on DOS compilers using the
			// medium memory model. It's so evil that I can't recommend it, but I've
			// implemented it anyway because it produces very nice asm code.

#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

			//				ClosurePtr<> - Safe version
			//
			// This implementation is standard-compliant, but a bit tricky.
			// I store the function pointer inside the class, and the delegate then
			// points to itself. Whenever the delegate is copied, these self-references
			// must be transformed, and this complicates the = and == operators.
		public:
			// The next two functions are for operator ==, =, and the copy constructor.
			// We may need to convert the ThisPtr pointers, so that
			// they remain as self-references.
			template< class DerivedClass >
			inline void CopyFrom(DerivedClass *pParent, const DelegateMemento &x) {
				SetMementoFrom(x);
				if (m_pStaticFunction != 0) {
					// transform self references...
					ThisPtr = reinterpret_cast<GenericClass *>(pParent);
				}
			}
			// For static functions, the 'static_function_invoker' class in the parent 
			// will be called. The parent then needs to call GetStaticFunction() to find out 
			// the actual function to invoke.
			template < class DerivedClass, class ParentInvokerSig >
			inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
				StaticFuncPtr fp) {
				if (fp == 0) { // cope with assignment to 0
					MemberFn = 0;
				}
				else {
					bindmemfunc(pParent, static_function_invoker);
				}
				m_pStaticFunction = reinterpret_cast<GenericFuncPtr>(fp);
			}
			inline StaticFuncPtr GetStaticFunction() const {
				return reinterpret_cast<StaticFuncPtr>(m_pStaticFunction);
			}
#else

			//				ClosurePtr<> - Evil version
			//
			// For compilers where data pointers are at least as big as code pointers, it is 
			// possible to store the function pointer in the this pointer, using another 
			// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
			// speeds up comparison and assignment. If C++ provided direct language support
			// for delegates, they would produce asm code that was almost identical to this.
			// Note that the Sun C++ and MSVC documentation explicitly state that they 
			// support static_cast between void * and function pointers.

			template< class DerivedClass >
			inline void CopyFrom(DerivedClass *pParent, const DelegateMemento &right) {
				SetMementoFrom(right);
			}
			// For static functions, the 'static_function_invoker' class in the parent 
			// will be called. The parent then needs to call GetStaticFunction() to find out 
			// the actual function to invoke.
			// ******** EVIL, EVIL CODE! *******
			template < 	class DerivedClass, class ParentInvokerSig>
			inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
				StaticFuncPtr fp) {
				if (fp == 0) { // cope with assignment to 0
					MemberFn = 0;
				}
				else {
					// We'll be ignoring the 'this' pointer, but we need to make sure we pass
					// a valid value to bindmemfunc().
					bindmemfunc(pParent, static_function_invoker);
				}

				// WARNING! Evil hack. We store the function in the 'this' pointer!
				// Ensure that there's a compilation failure if function pointers 
				// and data pointers have different sizes.
				// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
				typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *) == sizeof(fp) ? 1 : -1];
				ThisPtr = horrible_cast<GenericClass *>(fp);
				// MSVC, SunC++ and DMC accept the following (non-standard) code:
				//		ThisPtr = static_cast<GenericClass *>(static_cast<void *>(fp));
				// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
				//		ThisPtr = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(fp));
			}
			// ******** EVIL, EVIL CODE! *******
			// This function will be called with an invalid 'this' pointer!!
			// We're just returning the 'this' pointer, converted into
			// a function pointer!
			inline StaticFuncPtr GetStaticFunction() const {
				// Ensure that there's a compilation failure if function pointers 
				// and data pointers have different sizes.
				// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
				typedef int ERROR_CantUseEvilMethod[sizeof(StaticFuncPtr) == sizeof(this) ? 1 : -1];
				return horrible_cast<StaticFuncPtr>((intptr_t)this - sizeof(DelegateBase));
			}
#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

			// Does the closure contain this static function?
			inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr) {
				if (funcptr == 0) return empty();
				// For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
				// value that is not equal to any valid function pointer.
				else return funcptr == reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
			}
		};
	} // namespace Details

	  ////////////////////////////////////////////////////////////////////////////////
	  //						Fast Delegates, part 3:
	  //
	  //				Wrapper classes to ensure type safety
	  //
	  ////////////////////////////////////////////////////////////////////////////////


	  // Once we have the member function conversion templates, it's easy to make the
	  // wrapper classes. So that they will work with as many compilers as possible, 
	  // the classes are of the form
	  //   Delegate3<int, char *, double>
	  // They can cope with any combination of parameters. The max number of parameters
	  // allowed is 8, but it is trivial to increase this limit.
	  // Note that we need to treat const member functions seperately.
	  // All this class does is to enforce type safety, and invoke the delegate with
	  // the correct list of parameters.

	  // Because of the weird rule about the class of derived member function pointers,
	  // you sometimes need to apply a downcast to the 'this' pointer.
	  // This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below. 
	  // If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
	  // without this trick you'd need to write:
	  //		MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
	  // but with the trick you can write
	  //		MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);

	  // RetType is the type the compiler uses in compiling the template. For VC6,
	  // it cannot be void. DesiredRetType is the real type which is returned from
	  // all of the functions. It can be void.

	  // Implicit conversion to "bool" is achieved using the safe_bool idiom,
	  // using member data pointers (MDP). This allows "if (dg)..." syntax
	  // Because some compilers (eg codeplay) don't have a unique value for a zero
	  // MDP, an extra padding member is added to the SafeBool struct.
	  // Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
	  // in that case the static function constructor is not made explicit; this
	  // allows "if (dg==0) ..." to compile.

	class DelegateBase
	{
	protected:
		std::shared_ptr<Details::FunctorWrapperBase> m_Functor;
		CS::weak_ptr<IWeakReferenceSource2> m_WeakRef;

		template<typename T>
		typename std::enable_if<std::is_base_of<Ext::IWeakReferenceSource, T>::value, void>::type weakbind(T* pthis)
		{
			m_WeakRef = static_cast<Ext::IWeakReferenceSource*>(pthis);
		}

		template<typename T>
		typename std::enable_if<!std::is_base_of<Ext::IWeakReferenceSource, T>::value, void>::type weakbind(T* pthis)
		{
			m_WeakRef = nullptr;
		}

		template<typename F, typename C>
		void stlbind(const F& functor, C& closure)
		{
			auto ptr = new Details::FunctorWrapper<F>(functor);
			m_Functor = std::shared_ptr<Details::FunctorWrapperBase>(ptr);
			weakbind(&ptr->LiveFunctor);
			closure.bindmemfunc(Details::implicit_cast<F*>(&ptr->LiveFunctor), &F::operator());
			//		bindclosure(&ptr->LiveFunctor, &F::operator());
		}

		template<typename T>
		bool Test(const T& closure, com_ptr<IObject>& retain) const
		{
			if (!closure)
				return false;

			if (!m_WeakRef)
				return true;

			retain = m_WeakRef.Resolve();
			if (!retain)
			{
				const_cast<T*>(&closure)->clear();
				const_cast<weak_ptr<IWeakReferenceSource2>*>(&m_WeakRef)->Reset();
			}

			return !!retain;
		}
	};

	template<typename Signature>
	class Delegate;

	template<typename Ret, typename... Args>
	class Delegate<Ret(Args...)> : public DelegateBase
	{
		friend struct std::hash<Delegate<Ret(Args...)>>;

	private:
		typedef Ret(*StaticFunctionPtr)(Args...args);
		typedef Ret(Details::GenericClass::*GenericMemFn)(Args...args);
		typedef Details::ClosurePtr<GenericMemFn, StaticFunctionPtr> ClosureType;
		ClosureType m_Closure;

		// Implicit conversion to "bool" using the safe_bool idiom
		typedef struct SafeBoolStruct {
			int a__datapointer_to_this_is_0_on_buggy_compilers;
			StaticFunctionPtr m_nonzero;
		} UselessTypedef;
		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;

	public:
		// Null construction/assignment
		Delegate() { m_Closure.clear(); }
		Delegate(nullptr_t) { m_Closure.clear(); }
		void operator =(nullptr_t) { m_Closure.clear(); }

		// Copy construction/assignment
		Delegate(const Delegate &x) { m_Closure.CopyFrom(this, x.m_Closure); m_WeakRef = x.m_WeakRef; m_Functor = x.m_Functor; }
		void operator =(const Delegate &x) { m_Closure.CopyFrom(this, x.m_Closure); m_WeakRef = x.m_WeakRef; m_Functor = x.m_Functor; }

		// Static function construction/assignment.
		// We convert them into a member function call.
		Delegate(Ret(*fp)(Args...)) { bind(fp); }
		void operator =(Ret(*fp)(Args...)) { bind(fp); }

		// Member function contruction
		template<typename X, typename Y>
		Delegate(Y *pthis, Ret(X::* fp)(Args...)) { bind(pthis, fp); }
		template<typename X, typename Y>
		Delegate(const Y *pthis, Ret(X::* fp)(Args...) const) { bind(pthis, fp); }

		// Functors construction/assignment.
		// Need to retain them for the lifetime of the delegate
		template<typename F, typename = std::enable_if_t<std::is_same_v<Ret(Args...), signature_of<F>>>>
		Delegate(const F& functor) { stlbind(functor, m_Closure); }
		template<typename F, typename = std::enable_if_t<std::is_same_v<Ret(Args...), signature_of<F>>>>
		void operator =(const F& functor) { stlbind(functor, m_Closure); }

		// Comparison
		bool operator ==(const Delegate &x) const { return (m_Functor && x.m_Functor) ? (*m_Functor == *x.m_Functor) : m_Closure.IsEqual(x.m_Closure); }
		bool operator !=(const Delegate &x) const { return !(*this == x); }
		bool operator <(const Delegate &x) const { return (m_Functor && x.m_Functor) ? (*m_Functor == *x.m_Functor) : m_Closure.IsLess(x.m_Closure); }
		bool operator >(const Delegate &x) const { return (x < *this); }

		operator unspecified_bool_type() const { return empty() ? 0 : &SafeBoolStruct::m_nonzero; }
		// necessary to allow ==0 to work despite the safe_bool idiom
		inline bool operator ==(StaticFunctionPtr funcptr) { return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
		inline bool operator !=(StaticFunctionPtr funcptr) { return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
		inline bool operator !() const { return !m_Closure; }
		inline bool empty() const { return !m_Closure; }

		// Invocation
		Ret operator() (Args...args) const
		{
			com_ptr<IObject> retainer;
			if (Test(m_Closure, retainer))
				return (m_Closure.ThisPtr->*(reinterpret_cast<GenericMemFn>(m_Closure.MemberFn)))(args...);
			else
				return Ret();
		}

	private:
		// Binding to non-const member functions
		template<class X, class Y>
		inline void bind(Y *pthis, Ret(X::* fp)(Args...))
		{
			weakbind(pthis);
			m_Closure.bindmemfunc(Details::implicit_cast<X*>(pthis), fp);
		}

		// Binding to const member functions.
		template<class X, class Y>
		inline void bind(const Y *pthis, Ret(X::* fp)(Args...) const)
		{
			weakbind(pthis);
			m_Closure.bindconstmemfunc(Details::implicit_cast<const X *>(pthis), fp);
		}

		// Binding to static functions
		inline void bind(Ret(*fp)(Args...))
		{
			m_Closure.bindstaticfunc(this, &Delegate::InvokeStaticFunction, fp);
		}

		Ret InvokeStaticFunction(Args...args) const
		{
			return (*(m_Closure.GetStaticFunction()))(args...);
		}
	};

#define MemberDelegate(owner, member) MakeDelegate(owner, &__Ref<decltype(owner)>::Raw::member)
#define ThisDelegate(member) MemberDelegate(this, member)

	template<typename F> Delegate<signature_of<F>> MakeDelegate(F func)
	{
		return Delegate<signature_of<F>>(func);
	}

	template<typename T, typename F>
	Delegate<signature_of<F>> MakeDelegate(T* instance, F func)
	{
		return Delegate<signature_of<F>>(instance, func);
	}

} // namespace CS

IS_GENERIC_VALUETYPE(1, ::CS::Delegate, "32053C30-9B36-4DBA-A1B2-AF1F7608B66D");

namespace CS {
	namespace Details
	{
		// Add a special handler for signature types
		template<typename R, typename... P>
		struct Identifier<R(P...)> : public GenericInstanceID<&_uuidof_generic(CS::Delegate<R(P...)>), R, P...> { };
	}
}

namespace std
{
	template<>
	struct hash<::CS::Details::DelegateMemento>
	{
		size_t operator()(::CS::Details::DelegateMemento const& x) const
		{
			const int* ptrptr = static_cast<const int*>(static_cast<const void*>(&x.MemberFn));

			size_t ret = 0;
			for (int i = 0; i < (sizeof(::CS::Details::DelegateMemento::GenericMemFuncType) / sizeof(int)); i++)
				ret = ret ^ ptrptr[i];

			ret = ret ^ (size_t)x.ThisPtr;
			return ret;
		}
	};

	template<typename Signature>
	struct hash<::CS::Delegate<Signature>>
	{
		size_t operator()(::CS::Delegate<Signature> const& x) const
		{
			return std::hash<::CS::Details::DelegateMemento>()(x.m_Closure);
		}
	};
}